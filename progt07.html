<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Herencia, polimorfismo e interfaces</title>

		<meta name="description" content="Flujos">
		<meta name="author" content="Eladio Blanco">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">

		<!-- TEMA: beige, black, blood, league, moon, night, serif, simple, sky, solarized, white -->
		<link rel="stylesheet" href="css/theme/white.css" id="theme">

		<!-- CSS propio -->
		<link rel="stylesheet" href="css/micss.css">

		<!-- Theme used for syntax highlighting of code. Descargar de https://highlightjs.org/download/
			monokai, zenburn, vs2015.min.css, vs.min.css, github.min.css, github-dark.min.css ... -->
		<link rel="stylesheet" href="lib/css/monokai.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

				<!-- Título -->
				<section>
					<h1>Programación</h1>
					<h3>Tema 7: Herencia, polimorfismo e interfaces</h3>
					<p>
						<small><a href="http://www.eladioblanco.es">Eladio Blanco</a></small>
					</p>
				</section>

				<!-- Índice -->
				<section>
					<h2>Índice</h2>
					<ol>
						<li class="fragment highlight-blue">Relaciones entre clases</li>
						<li>Composición</li>
						<li>Herencia</li>
						<li>Clases abstractas</li>
						<li>Interfaces</li>
                        <li>Polimorfismo</li>
					</ol>
				</section>

				<!-- Relaciones entre clases -->
				<section>
					<h2>Relaciones entre clases</h2>
					<p>Es posible que no exista relación alguna entre clases, pero lo habitual es que sí, pudiendo ser la relación de:</p>
                    <ul>
                        <li><span class="naranja">Especialización</span>: Una clase añade características a otra clase base. Ej: Camión.</li>
                        <li><span class="naranja">Generalización</span>: Una clase es una versión más generíca de una subclase. Ej: Vehículo.</li>
                    </ul>
				</section>

				<!-- Relaciones entre clases -->
				<section>
					<h2>Relaciones entre clases</h2>
					<p>Tipos de relaciones entre clases:</p>
                    <ul>
                        <li><span class="naranja">Clientela</span>: Una clase utiliza objetos de otra clase. Ej: Uso de Scanner en el main.</li>
                        <li><span class="naranja">Composición</span>: Un atributo de una clase es un objeto de otra clase. Ej: Atributo titular de Cuenta es de tipo Cliente.</li>
                        <li><span class="naranja">Anidamiento</span>: Se declaran clases internas dentro de clases. Menos habitual. Ej: Clase Movimiento dentro de Cuenta.</li>
                        <li><span class="naranja">Herencia</span>: Clase base que comparte características con otras que añaden alguna funcionalidad. Ej: Clase base Cuenta de la que heredan CuentaAhorro, CuentaCorriente... </li>
                    </ul>
				</section>

				<!-- Relaciones entre clases -->
				<section>
					<h2>Relaciones entre clases</h2>
					<p>Composición</p>
                    <ul>
						<li>Una clase es parte de otra, es decir, un atributo de una clase es objeto de otra clase.</li>
						<li>Ej: Clase Pais con atributos que son objetos de la clase Comunidad, que a su vez tiene atributos objetos de clase Provincia.</li>
						<li>Para identificar la relación de composición &rarr; Usar <em>"tiene un"</em>.</li>
						<li>Ej: Coche tiene un Motor, tiene ruedas. Persona tiene una Cuenta, tiene expedientes...</li>
					</ul>
				</section>

				<!-- Relaciones entre clases -->
				<section>
					<h2>Relaciones entre clases</h2>
					<p>Herencia</p>
                    <ul>
						<li>Mecanismo para crear clases a partir de otras existentes.</li>
						<li>En Java, se sigue una jerarquía de clases partiendo de <strong>Object</strong>, de la que derivan todas las demás clases, incluidas las que nosotros definimos.</li>
					</ul>
				</section>

				<!-- Relaciones entre clases -->
				<section>
					<h2>Relaciones entre clases</h2>
					<p>Herencia</p>
                    <ul>
						<li>Las clases hijas heredan los atributos y métodos de la clase base, pudiendo además definir atributos y métodos propios.</li>
						<li>Los constructores no se heredan, pero desde el constructor hijo es posible llamar al del padre con <em>super</em>.</li>
						<li>Para identificar la relación de herencia &rarr; Usar <em>"es un"</em>.</li>
						<li>Ej: Coche es un Vehiculo, Empleado es una Persona, Cocodrilo es un Reptil.</li>
					</ul>
				</section>

				<!-- Índice -->
				<section>
					<h2>Índice</h2>
					<ol>
						<li>Relaciones entre clases</li>
						<li class="fragment highlight-blue">Composición</li>
						<li>Herencia</li>
						<li>Clases abstractas</li>
						<li>Interfaces</li>
						<li>Polimorfismo</li>
					</ol>
				</section>

				<!-- Composición -->
				<section>
					<h2>Composición</h2>
					<p>Ya la hemos utilizado al declarar como atributo de una clase, objetos de otra. A tener en cuenta:</p>
					<ul>
						<li>Al hacer un getter sobre un int, se devuelve el <em>valor</em> de la variable.  No modificable desde fuera.</li>
						<li>Al hacer un getter sobre un objeto, se devuelve la <em>referencia</em> (puntero) a su valor. Modificable desde fuera.</li>
					</ul>
				</section>

				<!-- Composición -->
				<section>
					<h2>Composición</h2>
					<p>Devolver referencias</p>
					<pre>
						<code class="hljs" data-trim> 
							public class Cuenta implements Serializable {
								private long numero;
								private Cliente titular;

								public Cliente getTitular() { 
									return titular; // Podrían cambiarlo desde fuera
								} 
							}
						</code>
					</pre>
				</section>

				<!-- Composición -->
				<section>
					<h2>Composición</h2>
					<p>Devolver objetos por valor</p>
					<pre>
						<code class="hljs" data-trim> 
							public class Cuenta implements Serializable {
								private long numero;
								private Cliente titular;

								public Cliente getTitular() { 
									Cliente aux = new Cliente(this.titular.getNombre(), this.titular.getApellidos(), ...);
									return aux; // Ya no pueden cambiar titular desde fuera
								} 
							}
						</code>
					</pre>
				</section>

				<!-- Composición -->
				<section>
					<h2>Composición</h2>
					<p>Ojo en los constructores, si cambia fuera el objeto referenciado, también cambiaría en la Cuenta</p>
					<pre>
						<code class="hljs" data-trim> 
							// Constructor
							public Cuenta(long numero, Cliente titular, float interes){
								this.numero = numero;
								this.titular = titular; // OJO!
								this.saldo = 0;
								this.interes = interes;
							}

							// Constructor copia
							public Cuenta(Cuenta c){
								this.numero = c.getNumero();
								this.titular = c.getTitular(); // OJO!
								this.saldo = c.getSaldo();
								this.interes = c.getInteres();
							}
						</code>
					</pre>
				</section>

				<!-- Composición -->
				<section>
					<h2>Composición</h2>
					<p>Prueba y corrije el siguiente código</p>
					<p><img src="img/progt07-01.png" alt="Código corregir referencias objetos" /></p>
				</section>

				<!-- Índice -->
				<section>
					<h2>Índice</h2>
					<ol>
						<li>Relaciones entre clases</li>
						<li>Composición</li>
						<li class="fragment highlight-blue">Herencia</li>
						<li>Clases abstractas</li>
						<li>Interfaces</li>
						<li>Polimorfismo</li>
					</ol>
				</section>

				<!-- Herencia -->
				<section>
					<h2>Herencia</h2>
					<ul>
						<li>Permite crear clases a partir de otras</li>
						<li>Las clases hijas no tienen acceso a los atributos privados heredados de la clase padre, pero serán accesibles a través de métodos getters y setters</li>
						<li>Las clases hijas pueden definir nuevos atributos y métodos. También sobreescribir métodos heredados</li>
					</ul>
				</section>

				<!-- Herencia -->
				<section>
					<h2>Herencia</h2>
					<p><img src="img/progt07-02.png" alt="Niveles de accesibilidad de atributos de una clase" /></p>
				</section>

				<!-- Herencia -->
				<section>
					<h2>Herencia</h2>
					<p>Ejemplo: Alumno hereda de Persona</p>
					<p><img src="img/progt07-03.png" alt="Herencia UML Persona Alumno" /></p>
				</section>

				<!-- Herencia -->
				<section>
					<h2>Herencia</h2>
					<p>Ejemplo: Alumno y Profesor heredan de Persona</p>
					<pre>
						<code class="hljs" data-trim> 
							public class Persona { 
								String nombre;
								String apellidos; 
								GregorianCalendar fechaNacim;
								...
							}
							// Alumno hereda de Persona
							public class Alumno extends Persona { 
								String grupo;
								double notaMedia;
								...
							}			
							// Profesor hereda de Persona
							public class Profesor extends Persona { 
								String especialidad;
								double salario;
								...
							}
						</code>
					</pre>
				</section>
				
				<!-- Herencia -->
				<section>
					<h2>Herencia</h2>
					<ul>
						<li>La clase Persona tiene 3 atributos</li>	
						<li>La clase Alumno tiene 5 atributos (3 heredados y 2 propios)</li>
						<li>La clase Profesor tiene 5 atributos (3 heredados y 2 propios)</li>
						<li>Los atributos heredados son accesibles a nivel de paquete. Si la clase heredada hubiera estado en otro paquete, dichos atributos tendrían que haber sido public o protected</li>
					</ul>
				</section>

				<!-- Herencia -->
				<section>
					<h2>Herencia</h2>
					<ul>
						<li>Mediante <em>super</em> accedemos a la clase padre para llamar a su constructor</li>
						<li>Si la clase hija sobreescribe un método de la clase padre es posible acceder al método del padre mediante <em>super.método()</em> (utilizado también para ampliar funcionalidad de un método)</li>
						<li>Al sobreescribir un método se puede cambiar su nivel de accesibilidad. Ej: protected en padre &rarr; public en hija</li>
					</ul>
				</section>

				<!-- Herencia -->
				<section>
					<h2>Herencia</h2>
					<p>Clase Persona</p>
					<pre>
						<code class="hljs" data-trim> 
							package modelo;
							import java.util.GregorianCalendar;

							public class Persona {
								protected String nombre;
								protected String apellidos;
								protected GregorianCalendar fechaNacim;

								public Persona(String nombre, String apellidos, GregorianCalendar fechaNacim) {
									this.nombre = nombre;
									this.apellidos = apellidos;
									this.fechaNacim = fechaNacim;
								}

								// Getters
								protected String getNombre(){
									return nombre; }
								public String getApellidos(){
									return apellidos; }
								public GregorianCalendar getFechaNacim(){
									return this.fechaNacim; }

								// Setters
								public void setNombre(String nombre){
									this.nombre = nombre; }
								public void setApellidos(String apellidos){
									this.apellidos = apellidos; }
								public void setFechaNacim(GregorianCalendar fechaNacim){
									this.fechaNacim = fechaNacim; }
							}

						</code>
					</pre>
				</section>

				<!-- Herencia -->
				<section>
					<h2>Herencia</h2>
					<p>Clase Alumno</p>
					<pre>
						<code class="hljs" data-trim> 
							package modelo;
							import java.util.GregorianCalendar;

							public class Alumno extends Persona{
								private String grupo;
								private double notaMedia;

								public Alumno(String nombre, String apellidos, GregorianCalendar fechaNacim, String grupo, double notaMedia) {
									super(nombre, apellidos, fechaNacim);
									this.grupo = grupo;
									this.notaMedia = notaMedia;
								}

								// Getters
								public String getGrupo(){ return grupo; }
								public double getNotaMedia (){ return notaMedia; }
								// Setters
								public void setGrupo(String grupo){ this.grupo = grupo; }
								public void setNotaMedia(double notaMedia){ this.notaMedia = notaMedia; }

								// Método sobreescrito
								public String getNombre(){
									return "Alumno " + nombre;
								}
							}
						</code>
					</pre>
				</section>

				<!-- Herencia -->
				<section>
					<h2>Herencia</h2>
					<p>Clase Profesor</p>
					<pre>
						<code class="hljs" data-trim> 
							package modelo;
							import java.util.GregorianCalendar;

							public class Profesor extends Persona{
								private String especialidad;
								private double salario;

								public Profesor(String nombre, String apellidos, GregorianCalendar fechaNacim, String especialidad, double salario) {
									super(nombre, apellidos, fechaNacim);
									this.especialidad = especialidad;
									this.salario = salario;
								}

								// Getters y Setters
								public String getEspecialidad() {
									return especialidad;
								}
								public void setEspecialidad(String especialidad) {
									this.especialidad = especialidad;
								}
								public double getSalario() {
									return salario;
								}
								public void setSalario(double salario) {
									this.salario = salario;
								}

								// Método sobreescrito
								public String getNombre(){
									return "Profesor " + nombre;
								}
							}
						</code>
					</pre>
				</section>

				<!-- Herencia -->
				<section>
					<h2>Herencia</h2>
					<p>Main</p>
					<pre>
						<code class="hljs" data-trim> 
							import modelo.*;
							import java.text.SimpleDateFormat;
							import java.util.Calendar;
							import java.util.GregorianCalendar;

							public class Main {
								public static void main(String[] args) {
									GregorianCalendar fecha1 = new GregorianCalendar(), fecha2 = new GregorianCalendar();
									SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
									// Nuevo alumno
									fecha1.set(2001, Calendar.JUNE, 6);
									Alumno alumno = new Alumno("Jose", "López García", fecha1, "1DAW", 9.3);
									// Nuevo profesor
									fecha2.set(1983, Calendar.MARCH, 24);
									Profesor profesor = new Profesor("Antonio", "Martínez Aranda", fecha2, "Programación", 1000);
									// Salida
									System.out.println(alumno.getNombre() + " " + alumno.getApellidos() + " ("+ sdf.format(alumno.getFechaNacim().getTime()) +")");
									System.out.println(profesor.getNombre() + " " + profesor.getApellidos() + " ("+ sdf.format(profesor.getFechaNacim().getTime()) +")");
								}
							}
						</code>
					</pre>
				</section>

				<!-- Herencia -->
				<section>
					<h2>Herencia</h2>
					<p>Main</p>
					<p><img src="img/progt07-04.png" alt="Salida programa ejemplo herencia" /></p>
				</section>

				<!-- Índice -->
				<section>
					<h2>Índice</h2>
					<ol>
						<li>Relaciones entre clases</li>
						<li>Composición</li>
						<li>Herencia</li>
						<li class="fragment highlight-blue">Clases abstractas</li>
						<li>Interfaces</li>
						<li>Polimorfismo</li>
					</ol>
				</section>

				<!-- Clases abstractas -->
				<section>
					<h2>Clases abstractas</h2>
					<p>Son clases de las que no se van a instanciar objetos directos, pero van a servir de base para que otras clases hereden de ellas</p>
					<p>Persona podría ser una clase abstracta</p>
					<p>Además de los métodos normales, pueden tener <em>métodos abstractos</em> obligatoriamente redefinidos en las clases derivadas</p>

				</section>

				<!-- Clases abstractas -->
				<section>
					<h2>Clases abstractas</h2>
					<p>Declaración con <em>abstract</em></p>
					<pre>
						<code class="hljs" data-trim> 
							public abstract class Persona { 
								protected String nombre;
								protected String apellidos; 
								protected GregorianCalendar fechaNacim;
								...
								// Método abstracto (no tienen cuerpo)
								protected abstract void mostrar();
							}
						</code>
					</pre>
				</section>

				<!-- Clases abstractas -->
				<section>
					<h2>Clases abstractas</h2>
					<p>Definición de métodos abstractos en clases derivadas</p>
					<pre>
						<code class="hljs" data-trim> 
							public class Alumno { 
								...
								// Método abstracto de Persona que hay que definir
								public void mostrar(){
									System.out.println(getNombre());
									System.out.println("Nota media: " + this.notaMedia);
								}
							}

							public class Profesor { 
								...
								// Método abstracto de Persona que hay que definir
								public void mostrar(){
									System.out.println(getNombre());
									System.out.println("Salario: " + this.salario);
								}
							}
						</code>
					</pre>
				</section>

				<!-- Clases abstractas -->
				<section>
					<h2>Clases abstractas</h2>
					<p>Salida en Main</p>
					<pre>
						<code class="hljs" data-trim> 
							// Salida métodos mostrar en Main
							alumno.mostrar();
							profesor.mostrar();
						</code>
					</pre>
					<p><img src="img/progt07-05.png" alt="Salida programa ejemplo clases abstractas" /></p>
				</section>

				<!-- Clases abstractas -->
				<section>
					<h2>Clases abstractas</h2>
					<p><em>Clases y métodos finales</em>: Las primeras no pueden ser heredadas y los segundos no pueden ser redefinidos</p>
					<p>Ambos se definen mediante el modificador <em>final</em>, el mismo que se utiliza para definir constantes</p>
				</section>

				<!-- Clases abstractas -->
				<section>
					<h2>Clases abstractas</h2>
					<p>Ejemplo método final no redefinible</p>
					<pre>
						<code class="hljs" data-trim> 
							public abstract class Persona { 
								...
								// Método final
								protected final String getNombre(){
									return nombre; 
								}
							}
						</code>
					</pre>
					<p>Error al sobreescribirlo en Profesor</p>
					<p><img src="img/progt07-06.png" alt="Error al sobreescribir método final" /></p>
				</section>

				<!-- Índice -->
				<section>
					<h2>Índice</h2>
					<ol>
						<li>Relaciones entre clases</li>
						<li>Composición</li>
						<li>Herencia</li>
						<li>Clases abstractas</li>
						<li class="fragment highlight-blue">Interfaces</li>
						<li>Polimorfismo</li>
					</ol>
				</section>

				<!-- Interfaces -->
				<section>
					<h2>Interfaces</h2>
					<ul>
						<li>Clase sin atributos que declara los métodos (sin cuerpo) que las clases que la implementen tendrán que definir obligatoriamente</li>
						<li>No es herencia. Lo que se consigue con las interfaz es definir un <em>comportamiento</em> común en las clases que la implementen</li>
					</ul>
				</section>

				<!-- Interfaces -->
				<section>
					<h2>Interfaces</h2>
					<p>Ejemplo</p>
					<p><img src="img/progt07-07.png" alt="Ejemplo interfaces" /></p>
				</section>

				<!-- Interfaces -->
				<section>
					<h2>Interfaces</h2>
					<ul>
						<li>Los nombres de las interfaces suelen acabar en <span class="naranja">-able, -or, -ente</span> para reflejar acciones: <em>serializable, clonable, servidor, buscador...</em></li>
						<li>Ejemplo: Coche y Bici heredan de Vehículo. Coche implementa interfaz <em>arrancable</em> con los métodos arrancarMotor y detenerMotor que Bici no necesita</li>
						<li>Una clase puede implementar varias interfaces, pero heredar sólo de una</li>
					</ul>
				</section>

				<!-- Interfaces -->
				<section>
					<h2>Interfaces</h2>
					<p>Diferencias con las clases abstractas</p>
					<ul>
						<li>Una clase puede implementar varias interfaces pero solo heredar de una clase</li>
						<li>Una interfaz no puede definir métodos, solo los enumera</li>
						<li>Una interfaz permite establecer el comportamiento de clase pero sin dar detalles, porque esos métodos se definen en la clase que la implemente</li>
						<li>La jerarquía de interfaces y de herencia son totalmente	distintas.</li>
					</ul>
				</section>

				<!-- Interfaces -->
				<section>
					<h2>Interfaces - Definición</h2>
					<p>No es necesario indicar los modificadores</p>
					<p><img src="img/progt07-08.png" alt="Definición de interfaces" /></p>
				</section>

				<!-- Interfaces -->
				<section>
					<h2>Interfaces - Definición</h2>
					<p><img src="img/progt07-09.png" alt="Ejercicio definición de interfaces" /></p>
				</section>

				<!-- Interfaces -->
				<section>
					<h2>Interfaces - Implementación</h2>
					<p>Una clase puede implementar cualquier interfaz. Basta con indicar <em>implements</em> y a continuación las clases a implementar separadas por comas</p>
					<pre>
						<code class="hljs" data-trim> 
							public class Coche implements serializable, arrancable { 
								...
							}
						</code>
					</pre>
				</section>

				<!-- Interfaces -->
				<section>
					<h2>Interfaces - Implementación</h2>
					<ul>
						<li>Vamos a implementar la interfaz <em>Imprimible</em> definida en el punto anterior</li>
						<li><span class="violeta">Opción 1:</span> Implementarla desde Alumno y Profesor y definir en ellos los métodos</li>
						<li><span class="violeta">Opción 2:</span> Implementarla desde Persona y ampliar la funcionalidad de sus métodos heredados en Alumno y Profesor (Seguiremos esta)</li>
					</ul>
				</section>

				<!-- Interfaces -->
				<section>
					<h2>Interfaces - Implementación</h2>
					<p>1. Se define la interfaz</p>
					<pre>
						<code class="hljs" data-trim> 
							package modelo;

							import java.util.ArrayList;
							import java.util.Hashtable;

							public interface Imprimible {
								String devolverContenidoString();
								ArrayList devolverContenidoArrayList();
								Hashtable devolverContenidoHashtable();
							}
						</code>
					</pre>
				</section>

				<!-- Interfaces -->
				<section>
					<h2>Interfaces - Implementación</h2>
					<p>2. Se implementa en Persona y se definen sus métodos</p>
					<pre>
						<code class="hljs" data-trim> 
							public abstract class Persona implements Imprimible{
								...
								// Métodos a implementar de la interfaz Imprimible
								public String devolverContenidoString() {
									SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
									String fecha = sdf.format(this.fechaNacim.getTime());
									String contenido = "{nombre: " + this.nombre + ", ";
									contenido = contenido + "apellidos: " + this.apellidos + ", ";
									contenido = contenido + "fechaNacim: " + fecha + "}";
									return contenido;
								}
								public ArrayList devolverContenidoArrayList () {
									ArrayList contenido = new ArrayList<>();
									SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
									String fecha = sdf.format(this.fechaNacim.getTime());
									contenido.add(this.nombre);
									contenido.add(this.apellidos);
									contenido.add(fecha);
									return contenido;
								}

								public Hashtable devolverContenidoHashtable() {
									Hashtable contenido = new Hashtable ();
									SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
									String fecha = sdf.format(this.fechaNacim.getTime());
									contenido.put ("nombre", this.nombre);
									contenido.put ("apellidos", this.apellidos);
									contenido.put ("fechaNacim", fecha); 
									return contenido;
								}
							}
						</code>
					</pre>
				</section>

				<!-- Interfaces -->
				<section>
					<h2>Interfaces - Implementación</h2>
					<p>3. Ya se pueden utilzar desde Alumno y Profesor</p>
					<pre>
						<code class="hljs" data-trim> 
							// Main - Uso de métodos implementados de Persona
							System.out.println(alumno.devolverContenidoString());
							System.out.println(profesor.devolverContenidoString());
						</code>
					</pre>
					<p><img src="img/progt07-10.png" alt="Salida implementación interfaces" /></p>
				</section>

				<!-- Interfaces -->
				<section>
					<h2>Interfaces - Implementación</h2>
					<p>4. Redefinir los métodos heredados en Alumno</p>
					<pre>
						<code class="hljs" data-trim> 
							public class Alumno extends Persona{
								...
								// Redefinir métodos heredados de Persona para mostrar atributos propios
								public String devolverContenidoString () {
									// Llamada al método del padre
									String contenido = super.devolverContenidoString();
									contenido = contenido + "grupo: " + this.grupo + ", ";
									contenido = contenido + "notaMedia: " + this.notaMedia;
									return contenido;
								}
								public ArrayList devolverContenidoArrayList () {
									// Llamada al método del padre
									ArrayList contenido = super.devolverContenidoArrayList();
									contenido.add(this.grupo);
									contenido.add(String.valueOf(this.notaMedia));
									return contenido;
								}

								public Hashtable devolverContenidoHashtable() {
									// Llamada al método del padre
									Hashtable contenido = super.devolverContenidoHashtable();
									contenido.put ("grupo", this.grupo);
									contenido.put ("notaMedia", String.valueOf(this.notaMedia));
									return contenido;
								}
							}
						</code>
					</pre>
				</section>

				<!-- Interfaces -->
				<section>
					<h2>Interfaces - Implementación</h2>
					<p>5. Redefinir los métodos heredados en Profesor</p>
					<pre>
						<code class="hljs" data-trim> 
							public class Profesor extends Persona{
								...
								// Redefinir métodos heredados de Persona para mostrar atributos propios
								public String devolverContenidoString () {
									// Llamada al método del padre
									String contenido = super.devolverContenidoString();
									contenido = contenido + "especialidad: " + this.especialidad + ", ";
									contenido = contenido + "salario: " + this.salario;
									return contenido;
								}
								public ArrayList devolverContenidoArrayList () {
									// Llamada al método del padre
									ArrayList contenido = super.devolverContenidoArrayList();
									contenido.add(this.especialidad);
									contenido.add(String.valueOf(this.salario));
									return contenido;
								}

								public Hashtable devolverContenidoHashtable() {
									// Llamada al método del padre
									Hashtable contenido = super.devolverContenidoHashtable();
									contenido.put ("grupo", this.especialidad);
									contenido.put ("notaMedia", String.valueOf(this.salario));
									return contenido;
								}
							}
						</code>
					</pre>
				</section>

				<!-- Interfaces -->
				<section>
					<h2>Interfaces - Implementación</h2>
					<p>6. Uso desde el Main</p>
					<pre>
						<code class="hljs" data-trim> 
							// Main - Uso de métodos implementados de Persona
							System.out.println(alumno.devolverContenidoString());
							System.out.println(profesor.devolverContenidoString());
						</code>
					</pre>
					<p><img src="img/progt07-11.png" alt="Salida implementación interfaces" /></p>
				</section>

				<!-- Índice -->
				<section>
					<h2>Índice</h2>
					<ol>
						<li>Relaciones entre clases</li>
						<li>Composición</li>
						<li>Herencia</li>
						<li>Clases abstractas</li>
						<li>Interfaces</li>
						<li class="fragment highlight-blue">Polimorfismo</li>
					</ol>
				</section>

				<!-- Polimorfismo -->
				<section>
					<h2>Polimorfismo</h2>
					<p>Posibilidad de manipular objetos de diferentes clases como si fueran de la misma</p>
					<p>Se consigue mediante la herencia, redefiniendo los métodos en las clases hijas</p>
					<p>Vamos a tener una estructura de datos de la superclase donde se guardarán objetos de las subclases</p>
				</section>

				<!-- Polimorfismo -->
				<section>
					<h2>Ligadura dinámica</h2>
					<p>Ligadura es la vinculación de la llamada a un método con la clase a la que pertenece. Puede ser <em>estática</em> si se resuelve en tiempo de compilación o <em>dinámica</em> si lo hace en tiempo de ejecución</em></p>
				</section>

				<!-- Polimorfismo -->
				<section>
					<h2>Polimorfismo y ligadura dinámica</h2>
					<p>Ej: Tenemos un array de Persona, lo recorremos y vamos llamando al método <em>mostrar</em>. En tiempo de ejecución se llamará al método correcto según haya un Alumno o Profesor en esa posición del array</p>
				</section>

				<!-- Polimorfismo -->
				<section>
					<h2>Polimorfismo y ligadura dinámica</h2>
					<pre>
						<code class="hljs" data-trim> 
							public static void main(String[] args) {
								var s = new Scanner(System.in);
								Persona persona;
								System.out.println("Introduce un número: ");
								int num = Integer.parseInt(s.nextLine());
								GregorianCalendar fecha = new GregorianCalendar();
								if(num % 2 == 0){
									fecha.set(2001, Calendar.JUNE, 6);
									// persona es polimórfico
									persona = new Alumno("Jose", "López García", fecha, "1DAW", 9.3);
								}else{
									fecha.set(1983, Calendar.MARCH, 24);
									// persona es polimórfico
									persona = new Profesor("Antonio", "Martínez Aranda", fecha, "Programación", 1000);
								}
								persona.mostrar(); // Ligadura dinámica
							}
						</code>
					</pre>
				</section>

				<!-- Polimorfismo -->
				<section>
					<h2>Polimorfismo y ligadura dinámica</h2>
					<p>Salida ejemplo</p>
					<p><img src="img/progt07-12.png" alt="Salida implementación ejemplo ligadura" /></p>
					<p><img src="img/progt07-13.png" alt="Salida implementación ejemplo ligadura" /></p>

				</section>
				

			
				<!-- Para repasar -->
				<section>
					<h2>Repasar</h2>
					<ul>
						<li><a href="https://www.w3schools.com/java/java_abstract.asp" target="_blank">w3schools - Clases abstractas</a></li>
						<li><a href="https://www.w3schools.com/java/java_interface.asp" target="_blank">w3schools - Interfaces</a></li>
						<li><a href="https://www.arquitecturajava.com/java-polimorfismo-herencia-y-simplicidad/" target="_blank">arquitecturajava - Polimorfismo</a></li>
					</ul>
				</section>
				
				<!-- Presentación en PDF -->
				<section>
					<h2>Tips de la presentación</h2>
					<p>¿Imprimir en PDF?</p>
					<ol>
						<li><a href="?print-pdf" target="_blank">Clic aquí</a></li>
						<li><kbd>CTRL</kbd>/<kbd>CMD</kbd> + <kbd>P</kbd></li>
						<li>Guardar como PDF</li>
					</ol>
					<p>Navegar por las diapositivas</p>
					<ol>
						<li>Pulsa <kbd>ESC</kbd></li>
						<li>Clic a la que quieras ir</li>
					</ol>
				</section>

				<!-- FIN -->
				<section data-background-image="img/progt07-fin.gif">
					<h2>A trabajar...</h2>
				</section>				
			</div>
		</div>

		<script src="js/reveal.js"></script>

		<script>

			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				center: true,
				hash: true,
				slideNumber: true, // true/none

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Parallax background image
				//parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',

				// Parallax background size
				//parallaxBackgroundSize: '2100px 900px',


				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true },
					{ src: 'plugin/search/search.js', async: true },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
